{
  "version": 3,
  "sources": ["../../wnumb/wNumb.js"],
  "sourcesContent": ["(function(factory) {\r\n  if (typeof define === \"function\" && define.amd) {\r\n    // AMD. Register as an anonymous module.\r\n    define([], factory);\r\n  } else if (typeof exports === \"object\") {\r\n    // Node/CommonJS\r\n    module.exports = factory();\r\n  } else {\r\n    // Browser globals\r\n    window.wNumb = factory();\r\n  }\r\n})(function() {\r\n  \"use strict\";\r\n\r\n  var FormatOptions = [\r\n    \"decimals\",\r\n    \"thousand\",\r\n    \"mark\",\r\n    \"prefix\",\r\n    \"suffix\",\r\n    \"encoder\",\r\n    \"decoder\",\r\n    \"negativeBefore\",\r\n    \"negative\",\r\n    \"edit\",\r\n    \"undo\"\r\n  ];\r\n\r\n  // General\r\n\r\n  // Reverse a string\r\n  function strReverse(a) {\r\n    return a\r\n      .split(\"\")\r\n      .reverse()\r\n      .join(\"\");\r\n  }\r\n\r\n  // Check if a string starts with a specified prefix.\r\n  function strStartsWith(input, match) {\r\n    return input.substring(0, match.length) === match;\r\n  }\r\n\r\n  // Check is a string ends in a specified suffix.\r\n  function strEndsWith(input, match) {\r\n    return input.slice(-1 * match.length) === match;\r\n  }\r\n\r\n  // Throw an error if formatting options are incompatible.\r\n  function throwEqualError(F, a, b) {\r\n    if ((F[a] || F[b]) && F[a] === F[b]) {\r\n      throw new Error(a);\r\n    }\r\n  }\r\n\r\n  // Check if a number is finite and not NaN\r\n  function isValidNumber(input) {\r\n    return typeof input === \"number\" && isFinite(input);\r\n  }\r\n\r\n  // Provide rounding-accurate toFixed method.\r\n  // Borrowed: http://stackoverflow.com/a/21323330/775265\r\n  function toFixed(value, exp) {\r\n    value = value.toString().split(\"e\");\r\n    value = Math.round(+(value[0] + \"e\" + (value[1] ? +value[1] + exp : exp)));\r\n    value = value.toString().split(\"e\");\r\n    return (+(value[0] + \"e\" + (value[1] ? +value[1] - exp : -exp))).toFixed(exp);\r\n  }\r\n\r\n  // Formatting\r\n\r\n  // Accept a number as input, output formatted string.\r\n  function formatTo(\r\n    decimals,\r\n    thousand,\r\n    mark,\r\n    prefix,\r\n    suffix,\r\n    encoder,\r\n    decoder,\r\n    negativeBefore,\r\n    negative,\r\n    edit,\r\n    undo,\r\n    input\r\n  ) {\r\n    var originalInput = input,\r\n      inputIsNegative,\r\n      inputPieces,\r\n      inputBase,\r\n      inputDecimals = \"\",\r\n      output = \"\";\r\n\r\n    // Apply user encoder to the input.\r\n    // Expected outcome: number.\r\n    if (encoder) {\r\n      input = encoder(input);\r\n    }\r\n\r\n    // Stop if no valid number was provided, the number is infinite or NaN.\r\n    if (!isValidNumber(input)) {\r\n      return false;\r\n    }\r\n\r\n    // Rounding away decimals might cause a value of -0\r\n    // when using very small ranges. Remove those cases.\r\n    if (decimals !== false && parseFloat(input.toFixed(decimals)) === 0) {\r\n      input = 0;\r\n    }\r\n\r\n    // Formatting is done on absolute numbers,\r\n    // decorated by an optional negative symbol.\r\n    if (input < 0) {\r\n      inputIsNegative = true;\r\n      input = Math.abs(input);\r\n    }\r\n\r\n    // Reduce the number of decimals to the specified option.\r\n    if (decimals !== false) {\r\n      input = toFixed(input, decimals);\r\n    }\r\n\r\n    // Transform the number into a string, so it can be split.\r\n    input = input.toString();\r\n\r\n    // Break the number on the decimal separator.\r\n    if (input.indexOf(\".\") !== -1) {\r\n      inputPieces = input.split(\".\");\r\n\r\n      inputBase = inputPieces[0];\r\n\r\n      if (mark) {\r\n        inputDecimals = mark + inputPieces[1];\r\n      }\r\n    } else {\r\n      // If it isn't split, the entire number will do.\r\n      inputBase = input;\r\n    }\r\n\r\n    // Group numbers in sets of three.\r\n    if (thousand) {\r\n      inputBase = strReverse(inputBase).match(/.{1,3}/g);\r\n      inputBase = strReverse(inputBase.join(strReverse(thousand)));\r\n    }\r\n\r\n    // If the number is negative, prefix with negation symbol.\r\n    if (inputIsNegative && negativeBefore) {\r\n      output += negativeBefore;\r\n    }\r\n\r\n    // Prefix the number\r\n    if (prefix) {\r\n      output += prefix;\r\n    }\r\n\r\n    // Normal negative option comes after the prefix. Defaults to '-'.\r\n    if (inputIsNegative && negative) {\r\n      output += negative;\r\n    }\r\n\r\n    // Append the actual number.\r\n    output += inputBase;\r\n    output += inputDecimals;\r\n\r\n    // Apply the suffix.\r\n    if (suffix) {\r\n      output += suffix;\r\n    }\r\n\r\n    // Run the output through a user-specified post-formatter.\r\n    if (edit) {\r\n      output = edit(output, originalInput);\r\n    }\r\n\r\n    // All done.\r\n    return output;\r\n  }\r\n\r\n  // Accept a sting as input, output decoded number.\r\n  function formatFrom(\r\n    decimals,\r\n    thousand,\r\n    mark,\r\n    prefix,\r\n    suffix,\r\n    encoder,\r\n    decoder,\r\n    negativeBefore,\r\n    negative,\r\n    edit,\r\n    undo,\r\n    input\r\n  ) {\r\n    var originalInput = input,\r\n      inputIsNegative,\r\n      output = \"\";\r\n\r\n    // User defined pre-decoder. Result must be a non empty string.\r\n    if (undo) {\r\n      input = undo(input);\r\n    }\r\n\r\n    // Test the input. Can't be empty.\r\n    if (!input || typeof input !== \"string\") {\r\n      return false;\r\n    }\r\n\r\n    // If the string starts with the negativeBefore value: remove it.\r\n    // Remember is was there, the number is negative.\r\n    if (negativeBefore && strStartsWith(input, negativeBefore)) {\r\n      input = input.replace(negativeBefore, \"\");\r\n      inputIsNegative = true;\r\n    }\r\n\r\n    // Repeat the same procedure for the prefix.\r\n    if (prefix && strStartsWith(input, prefix)) {\r\n      input = input.replace(prefix, \"\");\r\n    }\r\n\r\n    // And again for negative.\r\n    if (negative && strStartsWith(input, negative)) {\r\n      input = input.replace(negative, \"\");\r\n      inputIsNegative = true;\r\n    }\r\n\r\n    // Remove the suffix.\r\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/slice\r\n    if (suffix && strEndsWith(input, suffix)) {\r\n      input = input.slice(0, -1 * suffix.length);\r\n    }\r\n\r\n    // Remove the thousand grouping.\r\n    if (thousand) {\r\n      input = input.split(thousand).join(\"\");\r\n    }\r\n\r\n    // Set the decimal separator back to period.\r\n    if (mark) {\r\n      input = input.replace(mark, \".\");\r\n    }\r\n\r\n    // Prepend the negative symbol.\r\n    if (inputIsNegative) {\r\n      output += \"-\";\r\n    }\r\n\r\n    // Add the number\r\n    output += input;\r\n\r\n    // Trim all non-numeric characters (allow '.' and '-');\r\n    output = output.replace(/[^0-9\\.\\-.]/g, \"\");\r\n\r\n    // The value contains no parse-able number.\r\n    if (output === \"\") {\r\n      return false;\r\n    }\r\n\r\n    // Covert to number.\r\n    output = Number(output);\r\n\r\n    // Run the user-specified post-decoder.\r\n    if (decoder) {\r\n      output = decoder(output);\r\n    }\r\n\r\n    // Check is the output is valid, otherwise: return false.\r\n    if (!isValidNumber(output)) {\r\n      return false;\r\n    }\r\n\r\n    return output;\r\n  }\r\n\r\n  // Framework\r\n\r\n  // Validate formatting options\r\n  function validate(inputOptions) {\r\n    var i,\r\n      optionName,\r\n      optionValue,\r\n      filteredOptions = {};\r\n\r\n    if (inputOptions[\"suffix\"] === undefined) {\r\n      inputOptions[\"suffix\"] = inputOptions[\"postfix\"];\r\n    }\r\n\r\n    for (i = 0; i < FormatOptions.length; i += 1) {\r\n      optionName = FormatOptions[i];\r\n      optionValue = inputOptions[optionName];\r\n\r\n      if (optionValue === undefined) {\r\n        // Only default if negativeBefore isn't set.\r\n        if (optionName === \"negative\" && !filteredOptions.negativeBefore) {\r\n          filteredOptions[optionName] = \"-\";\r\n          // Don't set a default for mark when 'thousand' is set.\r\n        } else if (optionName === \"mark\" && filteredOptions.thousand !== \".\") {\r\n          filteredOptions[optionName] = \".\";\r\n        } else {\r\n          filteredOptions[optionName] = false;\r\n        }\r\n\r\n        // Floating points in JS are stable up to 7 decimals.\r\n      } else if (optionName === \"decimals\") {\r\n        if (optionValue >= 0 && optionValue < 8) {\r\n          filteredOptions[optionName] = optionValue;\r\n        } else {\r\n          throw new Error(optionName);\r\n        }\r\n\r\n        // These options, when provided, must be functions.\r\n      } else if (\r\n        optionName === \"encoder\" ||\r\n        optionName === \"decoder\" ||\r\n        optionName === \"edit\" ||\r\n        optionName === \"undo\"\r\n      ) {\r\n        if (typeof optionValue === \"function\") {\r\n          filteredOptions[optionName] = optionValue;\r\n        } else {\r\n          throw new Error(optionName);\r\n        }\r\n\r\n        // Other options are strings.\r\n      } else {\r\n        if (typeof optionValue === \"string\") {\r\n          filteredOptions[optionName] = optionValue;\r\n        } else {\r\n          throw new Error(optionName);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Some values can't be extracted from a\r\n    // string if certain combinations are present.\r\n    throwEqualError(filteredOptions, \"mark\", \"thousand\");\r\n    throwEqualError(filteredOptions, \"prefix\", \"negative\");\r\n    throwEqualError(filteredOptions, \"prefix\", \"negativeBefore\");\r\n\r\n    return filteredOptions;\r\n  }\r\n\r\n  // Pass all options as function arguments\r\n  function passAll(options, method, input) {\r\n    var i,\r\n      args = [];\r\n\r\n    // Add all options in order of FormatOptions\r\n    for (i = 0; i < FormatOptions.length; i += 1) {\r\n      args.push(options[FormatOptions[i]]);\r\n    }\r\n\r\n    // Append the input, then call the method, presenting all\r\n    // options as arguments.\r\n    args.push(input);\r\n    return method.apply(\"\", args);\r\n  }\r\n\r\n  function wNumb(options) {\r\n    if (!(this instanceof wNumb)) {\r\n      return new wNumb(options);\r\n    }\r\n\r\n    if (typeof options !== \"object\") {\r\n      return;\r\n    }\r\n\r\n    options = validate(options);\r\n\r\n    // Call 'formatTo' with proper arguments.\r\n    this.to = function(input) {\r\n      return passAll(options, formatTo, input);\r\n    };\r\n\r\n    // Call 'formatFrom' with proper arguments.\r\n    this.from = function(input) {\r\n      return passAll(options, formatFrom, input);\r\n    };\r\n  }\r\n\r\n  return wNumb;\r\n});\r\n"],
  "mappings": "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",
  "names": []
}
